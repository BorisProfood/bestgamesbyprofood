<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Шахром Мухтоджов — RPG прототип (Web)</title>
  <link rel="stylesheet" href="style.css">
  <style>
    #error {position:fixed;left:0;right:0;top:0;background:#c0392b;color:#fff;padding:8px 12px;font-size:14px;display:none;z-index:9999}
  </style>
</head>
<body>
  <div id="error"></div>
  <div id="hud">
    <div id="name">Шахром Мухтоджов</div>
    <div id="hpbar"><div id="hpfill"></div></div>
    <div id="hint">WASD — ходьба, Shift — бег, Space — прыжок, мышь — камера, ЛКМ — удар, ПКМ — щит</div>
  </div>
  <div id="overlay">
    <button id="start">Нажми для старта</button>
  </div>
  <canvas id="c"></canvas>

  <script type="module">
    const ERR = (msg) => { const e=document.getElementById('error'); e.textContent = msg; e.style.display='block'; };
    async function loadThree() {
      try {
        const THREE = await import('https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js');
        const { PointerLockControls } = await import('https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/controls/PointerLockControls.js');
        return { THREE, PointerLockControls };
      } catch (e1) {
        try {
          const THREE = await import('https://unpkg.com/three@0.159.0/build/three.module.js');
          const { PointerLockControls } = await import('https://unpkg.com/three@0.159.0/examples/jsm/controls/PointerLockControls.js');
          return { THREE, PointerLockControls };
        } catch (e2) {
          ERR('Не удалось загрузить движок (CDN заблокирован?). Обнови страницу или отключи блокировщик.'); 
          console.error(e1, e2);
          throw e2;
        }
      }
    }

    (async () => {
      const { THREE, PointerLockControls } = await loadThree();

      const canvas = document.getElementById('c');
      const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xbdd9ff);

      const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 5);

      const sun = new THREE.DirectionalLight(0xffffff, 1.1);
      sun.position.set(5, 10, 2);
      scene.add(sun, new THREE.AmbientLight(0xffffff, 0.35));

      const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshLambertMaterial({color:0x7bbf6a}));
      ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
      const road = new THREE.Mesh(new THREE.PlaneGeometry(200,6), new THREE.MeshLambertMaterial({color:0x7a5f44}));
      road.rotation.x = -Math.PI/2; road.position.y = 0.01; scene.add(road);

      function addTree(x,z) {
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.25,2,8), new THREE.MeshLambertMaterial({color:0x8b5a2b}));
        trunk.position.set(x,1,z);
        const crown = new THREE.Mesh(new THREE.SphereGeometry(1.2,12,12), new THREE.MeshLambertMaterial({color:0x2e8b57}));
        crown.position.set(x,2.4,z);
        scene.add(trunk,crown);
      }
      for (let i=0;i<80;i++) {
        const side = Math.random()<0.5?-1:1;
        addTree((Math.random()*40+6)*side, (Math.random()*180-90));
      }

      const player = new THREE.Object3D(); scene.add(player);
      player.position.set(0,0,0);
      const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.35,1.1,6,12), new THREE.MeshStandardMaterial({color:0xdddddd, metalness:0.1, roughness:0.8}));
      body.position.y = 1.2; scene.add(body);
      const shield = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,0.1,24), new THREE.MeshStandardMaterial({color:0x888899, roughness:0.7}));
      shield.position.set(0.5,1.2,-0.3); scene.add(shield);
      const sword = new THREE.Mesh(new THREE.BoxGeometry(0.1,1.0,0.1), new THREE.MeshStandardMaterial({color:0xcccccc}));
      sword.position.set(-0.5,1.0,-0.3); scene.add(sword);

      const controls = new PointerLockControls(camera, document.body);
      camera.position.set(0,1.6,0); player.add(camera);
      const overlay = document.getElementById('overlay');
      const startBtn = document.getElementById('start');
      startBtn.addEventListener('click', () => {
        if (document.body.requestPointerLock) {
          controls.lock();
        } else {
          // Fallback: просто скрываем оверлей и играем без PointerLock
          overlay.style.display='none';
          document.getElementById('hint').textContent += ' (Pointer Lock не поддерживается, управление мышью свободное)';
        }
      });
      controls.addEventListener('lock', ()=> overlay.style.display='none');
      controls.addEventListener('unlock', ()=> overlay.style.display='flex');

      const keys = {}; let shieldUp=false, canAttack=true;
      document.addEventListener('keydown', e => { keys[e.code]=true; if(e.code==='Space') e.preventDefault(); });
      document.addEventListener('keyup',   e => { keys[e.code]=false; });
      document.addEventListener('mousedown', e=>{ if(e.button===2) shieldUp=true; if(e.button===0) doAttack(); });
      document.addEventListener('mouseup', e=>{ if(e.button===2) shieldUp=false; });

      let velY=0, gravity=-25, isGrounded=true;
      let hp=100; const hpFill = document.getElementById('hpfill');
      function setHP(v){ hp=Math.max(0,Math.min(100,v)); hpFill.style.width=hp+'%'; if(hp<=0) document.getElementById('hint').textContent='Ты повержен. Обнови страницу для рестарта.'; }
      function popup(worldPos, text, color){
        const el=document.createElement('div'); el.className='popup'; el.textContent=text; el.style.color=color||'#fff'; document.body.appendChild(el);
        const v=worldPos.clone().project(camera); const x=(v.x*0.5+0.5)*innerWidth; const y=(-v.y*0.5+0.5)*innerHeight;
        el.style.left=(x-10)+'px'; el.style.top=(y-10)+'px';
        let t=0; const id=setInterval(()=>{ t+=16; el.style.transform=`translateY(${-t/20}px)`; el.style.opacity=String(Math.max(0,1-t/1200)); if(t>1200){clearInterval(id); el.remove();} },16);
      }

      function doAttack(){
        if(!canAttack) return; canAttack=false; sword.rotation.z = -0.8;
        setTimeout(()=>{sword.rotation.z=0;},200); setTimeout(()=>{canAttack=true;},400);
        const attackRange=1.8;
        enemies.forEach(e=>{
          const d=e.mesh.position.distanceTo(player.position);
          if(d<attackRange){
            const dir=new THREE.Vector3().copy(e.mesh.position).sub(player.position).normalize();
            const fwd=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
            if(dir.dot(fwd)>0.5) e.hit(25);
          }
        });
      }

      const enemies=[]; const arrows=[];
      function makeGoblin(x,z){
        const m=new THREE.Mesh(new THREE.CapsuleGeometry(0.35,0.8,6,12), new THREE.MeshStandardMaterial({color:0x5b8f36}));
        m.position.set(x,1.0,z); scene.add(m);
        const e={ type:'goblin', mesh:m, hp:50, cd:0,
          hit:(d)=>{ e.hp-=d; popup(m.position.clone().add(new THREE.Vector3(0,1.5,0)),'-'+Math.round(d),'#ffe680'); if(e.hp<=0){scene.remove(m); e.dead=true;} }
        }; enemies.push(e);
      }
      function makeElf(x,z){
        const m=new THREE.Mesh(new THREE.CapsuleGeometry(0.32,0.8,6,12), new THREE.MeshStandardMaterial({color:0x8fd1ff}));
        m.position.set(x,1.0,z); scene.add(m);
        const e={ type:'elf', mesh:m, hp:40, cd:0,
          hit:(d)=>{ e.hp-=d; popup(m.position.clone().add(new THREE.Vector3(0,1.5,0)),'-'+Math.round(d),'#ffe680'); if(e.hp<=0){scene.remove(m); e.dead=true;} }
        }; enemies.push(e);
      }
      function shootArrow(from,to){
        const geom=new THREE.ConeGeometry(0.05,0.4,8); const mat=new THREE.MeshStandardMaterial({color:0xdddddd});
        const arrow=new THREE.Mesh(geom,mat); const dir=to.clone().sub(from).setY(0).normalize();
        arrow.position.copy(from); arrow.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().setY(0.0001).normalize());
        scene.add(arrow); arrows.push({mesh:arrow, vel:dir.multiplyScalar(12), life:4});
      }

      for(let i=0;i<7;i++) makeGoblin((Math.random()<0.5?-1:1)*(Math.random()*4+2), -30+i*10+(Math.random()*6-3));
      for(let i=0;i<5;i++) makeElf((Math.random()<0.5?-1:1)*(Math.random()*4+2), -25+i*14+(Math.random()*6-3));

      function enemyUpdate(dt){
        const p2=new THREE.Vector3(player.position.x,0,player.position.z);
        enemies.forEach(e=>{
          if(e.dead) return;
          const pos2=new THREE.Vector3(e.mesh.position.x,0,e.mesh.position.z);
          const d=pos2.distanceTo(p2); e.cd=Math.max(0,e.cd-dt);
          if(d<18){
            const dir=p2.clone().sub(pos2).normalize();
            e.mesh.position.add(dir.clone().multiplyScalar((e.type==='goblin'?2.2:1.6)*dt));
            if(e.type==='goblin' && d<1.5 && e.cd<=0){
              e.cd=1.0; const dmg=shieldUp?5:12; setHP(hp-dmg); popup(player.position.clone().add(new THREE.Vector3(0,1.6,0)),'-'+dmg, shieldUp?'#ff5555':'#ff2222');
            }
            if(e.type==='elf' && d<14 && e.cd<=0){
              e.cd=1.6; const from=e.mesh.position.clone().add(new THREE.Vector3(0,1.2,0)); const to=player.position.clone().add(new THREE.Vector3(0,1.2,0));
              shootArrow(from,to);
            }
          }
        });
        for(let i=arrows.length-1;i>=0;i--){
          const a=arrows[i]; a.mesh.position.add(a.vel.clone().multiplyScalar(dt)); a.life-=dt;
          if(a.life<=0){ scene.remove(a.mesh); arrows.splice(i,1); continue; }
          if(a.mesh.position.distanceTo(player.position)<1.0){
            const dmg=shieldUp?4:10; setHP(hp-dmg); popup(player.position.clone().add(new THREE.Vector3(0,1.6,0)),'-'+dmg, shieldUp?'#ff7777':'#ff3333');
            scene.remove(a.mesh); arrows.splice(i,1);
          }
        }
      }

      let last=performance.now();
      function tick(now){
        const dt=Math.min(0.05,(now-last)/1000); last=now;
        const speed=(keys['ShiftLeft']||keys['ShiftRight'])?6:3.5;
        const forward=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
        const right=new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
        forward.y=0; right.y=0; forward.normalize(); right.normalize();
        let move=new THREE.Vector3();
        if(keys['KeyW']) move.add(forward);
        if(keys['KeyS']) move.sub(forward);
        if(keys['KeyA']) move.sub(right);
        if(keys['KeyD']) move.add(right);
        if(move.lengthSq()>0) move.normalize().multiplyScalar(speed*dt);

        if(isGrounded && keys['Space']){ velY=7.5; isGrounded=false; }
        velY += (-25)*dt; let newY = player.position.y + velY*dt;
        if(newY<=0){ newY=0; isGrounded=true; velY=0; }
        player.position.y=newY;
        player.position.add(move);

        body.position.copy(player.position).add(new THREE.Vector3(0,1.2,0));
        shield.position.copy(player.position).add(new THREE.Vector3(0.5,1.2,-0.3));
        sword.position.copy(player.position).add(new THREE.Vector3(-0.5,1.0,-0.3));

        enemyUpdate(dt);
        renderer.setSize(innerWidth, innerHeight);
        renderer.render(scene,camera);
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
      addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
    })();
  </script>
</body>
</html>
